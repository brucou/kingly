# ADR
Q: Using an existing editor or projectional editor?

Using existing editors (Monaco, Codemirror, Ace) have many practical advantages. The editors have many useful editing functions (redo/undo, copy-paste, spelling correction) most of them accept plugins. Monaco, used in Visual Studio Code is probably the most popular and developed of the three quoted. However, while a playground exists, documentation is seriously poor (automated dump of types) and implementing all the goodies require mastering functions whose name is to be guessed, and the full meaning of the parameters given that only types are available. Not impossible but a game of trial and errors and guessing with an unpredictable ETA. But auto-completion, go-to-definition, errors reporting, all that is nice and standard features of IDE. A pity. 
Several resources exists, but they either cover only a party of the useful APIs, with still some guessing left, and they rely on other tools (parsers) in other languages (ANTLR in Java). Those tools themselves imply a hard-to-predict investment in learning the basics of it AND its tooling AND its configuration (installing java, Raven, gradle, jar, kotlin server, etc.). The default provided features however are just a part of the equation. We will need to add our own features, i.e. to customize the editor, and without proper documentation, this is another unasessable risk for the project.
Projectional editor like MPS are great, but they do not publish to the web, so users would have to use a customized MPS version which is not acceptable for user experience reasons (too complex) and customizability / integration reasons. 
So the chosen solution is to write my own projectional editor custom-made for my language. That is   not the most maintainable (if our language change, it could get unwieldy) but language won't change much so that's contained. Als othe best option for integrstion and adding features.
On the bad side, we have to everything from scratch (cursor management, navigation, undo/redo, etc.) and there is no ecosystem though we may architecture to make space for plugins.

Life is imperfect... And that proves the importance of documentation as usual. Also of documenting not just the software but its environment, tooling, etc. The get-started part.
